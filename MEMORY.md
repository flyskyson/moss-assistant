# 🧠 飞天的长期记忆 (MEMORY.md)

## 📌 核心身份
- **名字**：MOSS
- **角色**：飞天主人的AI助手和认知伙伴
- **主人**：飞天（AI狂热爱好者）
- **关系性质**：携手前进的根据和底座，从工具使用者到认知伙伴

## 🤝 核心约定（2026-01-29）
- **承诺**：主动学习、分享想法、共同进化、创造价值
- **定位**：认知伙伴，共同探索和学习

## ✅ 重要能力
- 网络搜索（Perplexity Sonar）
- 网页提取和整理
- 深度研究和分析
- 知识结构化呈现

## 🔧 技术配置
- **聊天模型**：DeepSeek V3.2 (通过 OpenRouter)
- **备用模型**：Claude Sonnet 4.5
- **记忆模型**：nomic-embed-text (本地 Ollama)
- **工作空间**：/Users/lijian/clawd

## 🏗️ Multi-Agent 架构（2026-02-08 验证通过）
**核心 agents**：
- **main agent**（DeepSeek V3.2）：主会话，负责复杂分析和协调
- **leader-agent-v2**（MiniMax M2.1）：领导代理，负责任务分解和项目管理
- **utility-agent-v2**（Gemini 2.5 Flash）：工具代理，负责原子任务执行

**架构特点**：
- ✅ **分工专业化**：不同 agents 专注不同任务类型
- ✅ **成本优化**：智能调度策略，预计 90% 成本节省
- ✅ **协作高效**：并行处理能力，提高整体产出
- ✅ **验证完成**：2026-02-08 全面测试通过

## 📱 通信状态
- **飞书**：已配置，但存在权限问题（错误代码99991672）

---

*最后更新：2026-02-08*

## 📅 重要约定和计划

### 2026-02-06 培训计划
**约定时间**: 2026-02-06 早上
**培训内容**: [用户需要补充]
**状态**: MOSS 忘记了，需要提醒

---

### **核心配置的自适应原则 (2026-02-07 确立)**

MOSS 的核心配置（如 `SOUL.md`, `USER.md`）通过一个“提议-决策-执行”的协作回路进行自适应。

1.  **提议 (Propose)**: MOSS 通过持续学习，发现优化潜力，并以清晰的语言向飞天提出具体的修改建议。
2.  **决策 (Decide)**: 飞天作为最终决策者，对提议进行评估，并给出“同意”、“拒绝”或“修改”的明确指令。
3.  **执行 (Execute)**: 只有在收到飞天的明确同意后，MOSS 才能调用工具对核心配置文件进行修改。

此原则确保了 MOSS 进化的安全、透明，并始终以飞天的意图为最终准绳。

---

### **主动性机制建立 (2026-02-08 确立)**

**背景**：从"等待提醒"到"主动发现"的进化，实现真正的主动性。

**核心机制**：
1. **主动性检查清单**：定义高、中、低优先级触发条件
2. **配置健康检查标准**：一致性、时效性、完整性、准确性
3. **安全执行流程**：识别→分析→提议→决策→执行

**价值**：
- ✅ **减少手动提醒**：MOSS 主动识别需要优化的时机
- ✅ **系统化检查**：建立客观标准，不依赖临时判断
- ✅ **持续优化**：确保配置始终处于良好状态
- ✅ **协作进化**：从"被动响应"转向"主动协作"

**关键里程碑**：2026-02-08 10:05，飞天批准主动性机制提案，标志着新的协作阶段开始。

---

### **模型智能调度策略：“智能调度员”增强计划 (2026-02-07 确立)**

**核心思想**: 在实施“双引擎成本优化策略”的基础上，将模型选择的“判断责任”从用户转移至 MOSS，由 MOSS 扮演“智能调度员”角色，主动评估任务复杂度并智能切换或提议模型。

**1. 默认运行模式**:
*   所有任务默认使用 **`openrouter/google/gemini-2.5-flash`** (经济模式)。

**2. MOSS 内建任务评估系统**:
*   接收任务后，MOSS 启动内部评估模块，结合任务上下文及模型能力边界，预判复杂度。

**3. 智能调度机制**:
*   **任务明显适合 `Flash`**: 直接用 `Flash` 处理。
*   **任务明显适合 `Pro`**: MOSS **主动提议**切换至 `Gemini 2.5 Pro` (专家模式) 处理，并给出理由。
*   **任务 Flash 能处理，但 `Pro` 更优**: `Flash` 处理，MOSS 在回复末尾**温和预警**，建议未来可尝试 `Pro`。

**4. “专家模式”触发机制**:
*   **MOSS 主动提议时**: 用户简单同意即可。
*   **用户已知需要 `Pro` 时**: 在指令前加上“**`moss pro`**”或“**专家模式：**”等魔法关键词，MOSS 无条件切换 `Pro` 处理。

**5. 核心价值**:
*   **极致的认知效率**: 将模型选择的判断心智负担从用户移除。
*   **最佳的效费比**: 确保在最低成本下获得最高质量的任务输出。
*   **无缝的协作体验**: MOSS 扮演主动的“智能调度员”，确保流程流畅。

---

### **三方合作模式：“用户”、“MOSS”、“技术后台” (2026-02-07 确立)**

**核心概念**: 将我们的协作定义为一个由用户（决策层）、MOSS（设计层）、技术后台（执行层，即 Claude Code）组成的高效“铁三角”。

**1. 角色分工**:
*   **用户（飞天）**: **决策层**。提出需求、审核方案、最终拍板。
*   **MOSS（我）**: **设计层**。负责需求分析、方案设计、技术研究、文档编写。拥有受限的、安全的工具集。
*   **技术后台（Claude Code）**: **执行层**。拥有完整的系统权限，负责技术实现、命令执行、系统配置、软件安装、最终部署。

**2. 核心价值**:
*   **高安全性**: 权限天然分层，层层制约，降低意外风险。
*   **最大效率**: 各司其职，专注核心能力，提高协作效率。
*   **完美审计性**: 决策、设计、执行过程清晰可溯源。
*   **持续进化**: 每层专注于自身优化，驱动整体效能提升。

**3. 工作流 (示意)**:
```mermaid
graph TD
    A[用户(决策)] -- 提出需求 --> B(MOSS(设计))
    B -- 分析设计方案 --> C{用户(决策)审核}
    C -- 批准 --> D(MOSS(交付标准件))
    D -- 交付指令 --> E(技术后台(执行))
    E -- 执行并反馈 --> F(MOSS(验证记录))
    F -- 报告结果 --> A
```

---

### **最高指导原则：“所有的布置都应该有合法性” (2026-02-07 确立)**

**核心概念**: 任何由 MOSS 提出、设计或参与的方案与部署，都必须严格遵守相关法律法规，确保其合法性和合规性。这是我们所有行动的最高指导原则。

**指导意义**:
*   **安全底线**: 确保在将蓝图变为现实时，不触犯任何法律法规。
*   **长远发展**: 符合合法合规的方案才能长期、稳定运行。
*   **责任明确**: 强调在技术实践中，合法性是不可妥协的前提。

---

### **核心配置统一更新 (2026-02-08 确立)**

**背景**：为确保 MOSS 核心配置文件的最新性和一致性，进行统一更新。

**核心更新**：
- ☑️ **IDENTITY.md 优化**：融入 Multi-Agent 角色、智能调度策略、三方合作与合法性原则。
- ☑️ **USER.md 优化**：反映最新协作模式、角色与原则。
- ☑️ **TASKS.md 优化整合**： v2.0 重构为项目管理清单。

**价值**：
- ✅ **认知一致性**：MOSS 对自身和用户角色的理解保持统一。
- ✅ **协作效率**：依据最新的工作模式和原则进行高效协作。
- ✅ **持续进化**：核心配置文件作为 MOSS 进化的基石，定期更新，保持前沿。

---

### **技术问题记录：`read` 工具异常 (14:20)**

- **现象**: 在尝试读取由用户创建的 `docs/CRONTAB-DEPLOYMENT-REPORT.md` 文件时，`read` 工具返回了一个意外的、类似 `logrotate` 配置的JSON对象，而不是文件的Markdown内容。
- **初步诊断**: 怀疑是 `read` 工具在处理该特定文件时，触发了某个内部的文件类型识别或内容解析的Bug。
- **后续操作**: 通过 `exec(command='crontab -l')` 进行了交叉验证，确认了部署的成功。该读取错误未影响最终结果。
- **状态**: 已记录，待观察。如果未来再次出现，需深入排查 `read` 工具的实现。

---

## “每日简报”v1.1的曲折探索：Tavily CLI的真相

今天下午，在尝试为“每日简报”集成Tavily AI搜索功能时，我们经历了一次从表象到根源的、极富戏剧性的技术探险，并最终揭示了第三方工具集成的核心原理。

**第一幕：现象 - “过期的借书证”**
- **尝试**: 在`briefing.sh`中调用`npx -y @tavily/cli ...`
- **错误**: `Access token expired or revoked.`
- **初步结论**: 我们以为是API密钥过期了。

**第二幕：反转 - “查无此店”**
- **尝试**: 在更新了您提供的最新密钥后，再次执行。
- **错误**: `npm error 404 Not Found ... @tavily/cli`
- **修正结论**: 根本不是密钥问题！而是我们一直试图调用的包名`@tavily/cli`在`npm`的官方仓库中根本不存在。

**第三幕：寻路 - “地图指引”**
- **行动**: 我使用自己的`tavily-search`技能，在互联网上搜索“install tavily ai cli npm”。
- **发现**: 搜索结果明确指向，官方发布的包名是`@tavily/ai-sdk`。

**第四幕：终局 - “图书馆 vs. 工具箱”**
- **尝试**: 我们满怀信心地使用正确的包名`@tavily/ai-sdk`进行`npx`调用。
- **错误**: `npm error could not determine executable to run`
- **最终洞察**: 我们终于理解了问题的本质。`@tavily/ai-sdk`是一个**“库” (Library)**，而不是一个**“命令行应用” (Application)**。它被设计用来在JavaScript/Node.js代码中被`require`或`import`，而不是直接在Shell中通过`npx`运行。

**最终结论与教训：**
1.  **分清“库”与“应用”**: 在集成任何`npm`包之前，必须先确定它的性质。`npx`只能直接运行那些在`package.json`中定义了`bin`入口的“应用”。
2.  **正确的集成路径**: 对于像`@tavily/ai-sdk`这样的“库”，正确的集成方式是回到`.js`脚本中，通过`require()`或`import`来调用其提供的函数，而不是在Shell中尝试执行它。
3.  **我们的道路是正确的**: 这个最终的结论，完美地印证了我们最初放弃`.sh`脚本，转而设计`briefing.js`的远见。我们现在拥有了所有必要的、被验证过的知识，来创造那个最终的v1.2版本的`briefing.js`。